'''
Примем некоторые своевольные условности:
- Не стоит ожидать валидных данных на входе, никому нельзя верить, потому подготовим входящие файлы сами
- Коэффициенты членов неотрицательные, т.е. операция одна - сложение
- Используем многочлен, а не уравнение (как в 33 задании), т.е. не дописываем равенство нулю
- Член многочлена записывается в общем виде: CxP
    , где C - коэффициент, P - показатель степени, x - литера математической переменной
- Опускаем коэффициент и/или показатель степени согласно математической записи
'''

from random import randint

def to_string(val): # val - представление многочлена в виде списка
    ''' из списка слагаемых в виде [коэффициент, степень] в строку '''
    res = '' # сюда будем дописывать строковое представление многочлена
    for c, p in val: # c - коэффициент, p - степень
        if p == 0 or c > 1 and p > 0: # если без X или > 1 и рядом с X
            res += str(c) # то пишем коэффициент
        if p > 0: # если степень > 0
            res += 'x' # то пишем X
        if p > 1: # если степень > 1
            res += str(p) # то пишем степень
        res += ' + ' # добавляем плюс
    return res[:-3] # убираем последний (лишний) плюс при возврате результата

def from_string(val): # val - строковое представление многочлена
    ''' из строки в список слагаемых вида [коэффициент, степень] '''
    res = [] # в этот список будем добавлять списки [коэффициент, степень], т.е. слагаемые многочлена
    for i in val.split('+'): # делим по плюсам
        cp = i.lower().strip().split('x') # убираем пробелы и делим по X
        if len(cp) == 1: # был только коэффициент (без X)
            cp.append('0') # значит добавим нулевую степень X
        if len(cp[0]) == 0: # если коэффициент - пустая строка
            cp[0] = '1' # то коэффициент = 1 (1*x)
        if len(cp[1]) == 0: # если степень - пустая строка
            cp[1] = '1' # то степень = 1 (X**1)
        cp = list(map(int, cp)) # преобразуем коэффициент и степень в числа
        res.append(cp) # добавляем к результату
    return res # возвращаем многочлен в виде списка [коэффициент, степень] по каждому члену

def prepare_your_polynomanus(fname, n): # fname - имя файла, n - "порядок" многочлена (максимальная степень + 1)
    ''' создание входящего файла со строковым представлением многочлена '''
    poly = [[randint(0, 5), n - i - 1] for i in range(n)] # задаем список случайных коэффициентов (от 0 до 5)
    poly = [x for x in poly if x[0] != 0] # оставляем только ненулевые коэффициенты (мы так условились)
    poly = to_string(poly) # переводим в строковое представление для дальнейших манипуляций
    with open(fname, 'w') as f: # пересоздаем файл с заданным именем
        f.write(poly) # пишем в него строковое представление многочлена
    print(poly, '->', fname) # выводим что произошло для наглядности

def just_sum_it(val_1, val_2): # val_1, val_2 - суммируемые многочлены в виде списков их слагаемых
    ''' сумма многочленов, каждый в виде списка [коэффициент, степень] '''
    res = [] # в этом списке будет сумма многочленов
    i, j = 0, 0 # счетчики: i - по первому многочлену, j - по второму
    while i < len(val_1) and j < len(val_2): # пока не переберем все слагаемые обоих многочленов
        if val_1[i][1] > val_2[j][1]: # если степень слагаемого в первом многочлене больше
            res.append(val_1[i]) # то добавляем слагаемое первого многочлена к результату
            i += 1 # и "ставим указатель" на следующее слагаемое первого многочлена (на более младшую степень)
        elif val_1[i][1] < val_2[j][1]: # если степень слагаемого второго многочлена больше
            res.append(val_2[j]) # то добавляем слагаемое второго многочлена к результату
            j += 1  # и "ставим указатель" на следующее слагаемое второго многочлена (на более младшую степень)
        else: # если степени слагаемых двух многочленов равны
            res.append([val_1[i][0] + val_2[j][0], val_1[i][1]]) # то добавляем сумму коэффициентов слагаемых с той же степенью
            i += 1 # и "двигаем указатель"
            j += 1 # по слагаемым обоих многочленов
    return res # вернем сумму в виде списка [коэффициент, степень] по каждому члену

##### ТОЧКА ВХОДА #####
fname_1, fname_2, fname_res = 'task35_1.txt', 'task35_2.txt', 'task35_res.txt' # задаем имена файлов
prepare_your_polynomanus(fname_1, 10) # готовим первый входной файл
prepare_your_polynomanus(fname_2, 10) # готовим второй входной файл
with open(fname_1, 'r') as f: # открываем первый файл на чтение
    poly_1 = f.readline() # читаем строку (строковое представление многочлена)
    print(poly_1, '<-', fname_1) # выводим что произошло для наглядности
    poly_1 = from_string(poly_1) # преобразуем в список слагаемых
with open(fname_2, 'r') as f: # открываем второй файл на чтение
    poly_2 = f.readline() # читаем строку (строковое представление многочлена)
    print(poly_2, '<-', fname_2) # выводим что произошло для наглядности
    poly_2 = from_string(poly_2) # преобразуем в список слагаемых
poly_res = just_sum_it(poly_1, poly_2) # суммируем многочлены (в виде списков слагаемых)
poly_res = to_string(poly_res) # преобразуем результат в строку
with open(fname_res, 'w') as f: # пересоздаем результирующий файл
    f.write(poly_res) # пишем в него строковое представление результата
    print(poly_res, '->', fname_res) # выводим что произошло для наглядности